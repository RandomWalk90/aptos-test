import{a as l,c as u,h as H}from"./index.js";import{aS as k,e$ as g,bG as _}from"./index2.js";function L(e,t){for(var o=0;o<t.length;o++){const n=t[o];if(typeof n!="string"&&!Array.isArray(n)){for(const a in n)if(a!=="default"&&!(a in e)){const r=Object.getOwnPropertyDescriptor(n,a);r&&Object.defineProperty(e,a,r.get?r:{enumerable:!0,get:()=>n[a]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var i={};Object.defineProperty(i,"__esModule",{value:!0});var A=i.generateSalt=R=i.serializeBufferForStorage=J=i.serializeBufferFromStorage=M=i.keyFromPassword=E=i.exportKey=C=i.importKey=I=i.decryptWithKey=z=i.decryptWithDetail=v=i.decrypt=N=i.encryptWithKey=P=i.encryptWithDetail=F=i.encrypt=void 0;const D="jwk",S="AES-GCM",w="utf-8";async function O(e,t,o,n=b()){const a=o||await d(e,n),r=await x(a,t);return r.salt=n,JSON.stringify(r)}var F=i.encrypt=O;async function X(e,t,o=b()){const n=await d(e,o,!0),a=await K(n);return{vault:await O(e,t,n,o),exportedKeyString:a}}var P=i.encryptWithDetail=X;async function x(e,t){const o=JSON.stringify(t),n=l.Buffer.from(o,w),a=u.crypto.getRandomValues(new Uint8Array(16)),r=await u.crypto.subtle.encrypt({name:S,iv:a},e,n),c=new Uint8Array(r),s=l.Buffer.from(a).toString("base64");return{data:l.Buffer.from(c).toString("base64"),iv:s}}var N=i.encryptWithKey=x;async function T(e,t,o){const n=JSON.parse(t),{salt:a}=n,r=o||await d(e,a);return await j(r,n)}var v=i.decrypt=T;async function Y(e,t){const o=JSON.parse(t),{salt:n}=o,a=await d(e,n,!0),r=await K(a),c=await T(e,t,a);return{exportedKeyString:r,vault:c,salt:n}}var z=i.decryptWithDetail=Y;async function j(e,t){const o=l.Buffer.from(t.data,"base64"),n=l.Buffer.from(t.iv,"base64");let a;try{const r=await crypto.subtle.decrypt({name:S,iv:n},e,o),c=new Uint8Array(r),s=l.Buffer.from(c).toString(w);a=JSON.parse(s)}catch{throw new Error("Incorrect password")}return a}var I=i.decryptWithKey=j;async function q(e){return await u.crypto.subtle.importKey(D,JSON.parse(e),S,!0,["encrypt","decrypt"])}var C=i.importKey=q;async function K(e){const t=await u.crypto.subtle.exportKey(D,e);return JSON.stringify(t)}var E=i.exportKey=K;async function d(e,t,o=!1){const n=l.Buffer.from(e,w),a=l.Buffer.from(t,"base64"),r=await u.crypto.subtle.importKey("raw",n,{name:"PBKDF2"},!1,["deriveBits","deriveKey"]);return await u.crypto.subtle.deriveKey({name:"PBKDF2",salt:a,iterations:1e4,hash:"SHA-256"},r,{name:S,length:256},o,["encrypt","decrypt"])}var M=i.keyFromPassword=d;function Q(e){const t=e.slice(0,2)==="0x"?e.slice(2):e,o=new Uint8Array(t.length/2);for(let n=0;n<t.length;n+=2){const a=t.substr(n,2);o[n/2]=parseInt(a,16)}return o}var J=i.serializeBufferFromStorage=Q;function Z(e){let t="0x";return e.forEach(o=>{t+=ee(o)}),t}var R=i.serializeBufferForStorage=Z;function ee(e){let t=e.toString(16);for(;t.length<2;)t=`0${t}`;return t}function b(e=32){const t=new Uint8Array(e);return u.crypto.getRandomValues(t),btoa(String.fromCharCode.apply(null,t))}A=i.generateSalt=b;const se=L({__proto__:null,get decrypt(){return v},get decryptWithDetail(){return z},get decryptWithKey(){return I},default:i,get encrypt(){return F},get encryptWithDetail(){return P},get encryptWithKey(){return N},get exportKey(){return E},get generateSalt(){return A},get importKey(){return C},get keyFromPassword(){return M},get serializeBufferForStorage(){return R},get serializeBufferFromStorage(){return J}},[i]);let W=!1;function te(e,t,o){let n;H.storage.local.get(["keyringSetup","Wallet"]).then(r=>{var c,s,y,f,h,p,m;if((c=r==null?void 0:r.keyringSetup)!=null&&c.vault&&((y=(s=r==null?void 0:r.keyringSetup)==null?void 0:s.vault)==null?void 0:y.trim())!==""){const G=(h=(f=r==null?void 0:r.keyringSetup)==null?void 0:f.vault)==null?void 0:h.trim(),V=((p=r==null?void 0:r.Wallet)==null?void 0:p.accounts)??[],$=U(e,G,V,!!((m=r==null?void 0:r.keyringSetup)!=null&&m.setupCompleted));n=t(a($))}else o()});const a=r=>async(c,s=!1)=>{try{if(W)return"Another process in progress, please repeat in 5 seconds";const y=await r(c,s);if(y===void 0){o(),n==null||n();return}return y}catch{return"Something went wrong, please try again later"}finally{W=!1}}}const U=(e,t,o,n)=>async(a,r=!1)=>{try{if(r&&a===void 0)return;if(a===void 0)return"Incorrect password";const s=(await v(a,t)).map(m=>re(m)).filter(Boolean),y=e.getContainer(),f=await y.get(k.WalletControllerProvider)(),p=(await y.get(k.KeyringControllerProvider)()).store.getState();if(!p.hasVault)await f.createEmptyVault(a),await B({walletController:f,setupCompleted:n,keyrings:s,oldAccounts:o});else if(p.isUnlocked)await B({walletController:f,setupCompleted:n,keyrings:s,oldAccounts:o});else return console.log("[Migration] Need unlock wallet first"),"Need unlock wallet first"}catch(c){if(console.error(c),(c==null?void 0:c.message)==="Incorrect password")return c.message}},B=async({keyrings:e,walletController:t,setupCompleted:o,oldAccounts:n})=>{for(const r of e)switch(r.type){case g.KeyTree:try{await t.importKeyTreeWallet(_.Aptos,r.mnemonic,void 0,r.options,{isConfirmed:o})}catch(s){if((s==null?void 0:s.message)==="KeyTree keyring already exists"){console.log("[migration] find duplicate wallet");break}throw s}break;case g.Imported:let c=0;for(const s of r.keys)try{c++,await t.importAccount(_.Aptos,s)}catch(y){if((y==null?void 0:y.message)==="Account already exists"){console.log(`[migration] find duplicate account ${c}`);continue}throw y}break}const{accounts:a}=t.store.getState();for(const r of n){const c=a.find(s=>s.address===r.address);c&&await t.editAccountName(c.id,r.name)}};function re(e){switch(e[0]){case"Aptos Key Tree":return ne(e[1]);case"Simple Key Pair":return oe(e[1]);case"Ledger Account":return{type:g.Ledger}}}function ne({mnemonic:e,numberOfAccounts:t}){return{type:g.KeyTree,mnemonic:e,options:{accounts:Array.from({length:t},(o,n)=>({deriveIndex:n}))}}}function oe(e){return{type:g.Imported,keys:e}}const ae={version:"2.5.1",type:"async",up:te},ye=Object.freeze(Object.defineProperty({__proto__:null,default:ae,migrateWalletData:U},Symbol.toStringTag,{value:"Module"}));export{ae as a,ye as m,se as p};
